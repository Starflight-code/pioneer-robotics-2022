#include "PID.cpp"
#include "algorithms.cpp"
#include "pros/adi.hpp"
#include "pros/llemu.hpp"
#include "pros/misc.h"
#include "pros/misc.hpp"
#include "pros/motors.hpp"
#include "pros/rtos.hpp"
#include "pros/screen.hpp"
#include "pros/vision.hpp"
#include <algorithm>
#include <array>
#include <cmath>
#include <vector>
class events {
private:
    std::vector<pros::Controller> control;
    Motor_Class Motors;
    algorithms algo;
    /** This loop is for training commands, and will only be active while training mode is active.

    */
    void training() {
        if(control[0].get_digital(pros::E_CONTROLLER_DIGITAL_LEFT)) {
            Motors.Robot.limiter = (double)(control[0].get_analog(ANALOG_LEFT_X) + algo._RANGE) / 254;
        }
    }

public:
    events(Motor_Class Motor_Class_Object) {
        this->Motors = Motor_Class_Object;
        control.push_back(pros::Controller(pros::E_CONTROLLER_MASTER));
    }

    void main() {
        if(Motors.Robot.training) {
            training();
        }
    }
};

class cl {
private:
    // double limiter; // Global limiter value (double w/ range [0 <-> 1]) FUNCTIONALITY SENT TO robots.cpp
    double sc = 0; // Scaling constant, for use with arcade control system
    // const int _RANGE = 170;              // Range of vex motors/controls (max value allowed) FUNCTIONALITY SENT TO algorithms.cpp
    const int _SPINNER_SPEED = 60;       // Speed that spinner will spin at
    const int _SPINNER_DRIVE_SPEED = 10; // Speed for drive motors to push robot
                                         // forward, keeping contact with spinner
    bool spinnerActive = false;          // Allows for control while pushing robot forward
                                         // for spinner (Quality of Life)
    Control Flywheels;                   // PID and other control alogrithms
    std::array<int, 2> controller_values;
    std::array<pros::controller_analog_e_t, 2> sticks;

public:
    Motor_Class Motors;
    algorithms algo;

    cl(Motor_Class Motor_Object) {
        this->Motors = Motor_Object;
        // limiter = Motors.Robot.limiter;
    }
    /// Applies motor speeds following the preset control scheme for the drive.
    /// @return N/A
    void controls() {

        pros::Controller master(pros::E_CONTROLLER_MASTER); // Imports Controller as "master"
        // Set sticks arrays to correct values for current configuration
        if(Motors.Robot.controlScheme == 0) {
            sticks = {ANALOG_LEFT_Y, ANALOG_RIGHT_Y}; // Tank control
        } else {
            sticks = {ANALOG_LEFT_Y, ANALOG_RIGHT_X}; // Arcade Control
        }

        if(Motors.Robot.exponential_control) { // Apply exponential control altering and populate controller_values array
            for(int i = 0; i < controller_values.size(); i++) {
                controller_values[i] = algo.exponential_control(master.get_analog(sticks[i]), Motors.Robot.control_exponent_value);
            }
        } else {
            for(int i = 0; i < controller_values.size(); i++) { // Populate controller_values
                                                                // array with raw stick values
                controller_values[i] = master.get_analog(sticks[i]);
            }
        }

        Motors.leftMotors.set(controller_values[0]);
        Motors.rightMotors.set(controller_values[1]);

        switch(Motors.Robot.controlScheme) {
        case 0: // Tank Control
            for(int i = 0; i < controller_values.size(); i++) {
                Motors.Motors[i].set(algo.tank_control(controller_values[i], Motors.Robot.limiter));
            }
            break;
        case 1: // Split Arcade

            /*if (-1 < (controller_value) and
              (controller_value < 1) and spinnerActive) {
            Motors.setSpeed(1, _SPINNER_DRIVE_SPEED);
            Motors.setSpeed(2, _SPINNER_DRIVE_SPEED);
          } else {*/
            // Designed to allow a mix of left/right forward/backwards inputs, so
            // the scaling coefficient prevents overflow (values >170)
            /*sc = (abs(controller_value) +
                  abs(controller_x_value));
            if (sc < _RANGE) {sc = _RANGE;}*/
            // If it isn't limiting the value (making the value larger instead),
            // set it to do nothing (multiply by 1 (127/127))

            // Sets the motors to the values generated by the LEFT_Y and RIGHT_X
            // stick ranges Left_Y stick controls forward/backwards Right_X stick
            // controls left/right and local limiter still works
            /*Motors.setSpeed(
                1, int((-(controller_value / (sc / _RANGE) +
                          controller_x_value / (sc / _RANGE)) *
                        (local_limiter / 100))));
            Motors.setSpeed(
                2, int(((controller_value / (sc / _RANGE) -
                         controller_x_value / (sc / _RANGE)) *
                        (local_limiter / 100))));*/
            std::array<int, 2> motorValues;
            motorValues = algo.arcade_control(controller_values[0], controller_values[1], Motors.Robot.limiter);
            for(int i = 0; i < motorValues.size(); i++) {
                Motors.Motors[i].set(motorValues[i]);
            }
            //}
            break;
        default:
            // SHOULD NEVER OCCUR, but if it does...
            // There is an error in variables.cpp in
            // the Robot.controlScheme variable preset
            break;
        }
    }

    void event_listener() {
    }

public:
    /** Control Listening Service
     *
     * Pulls from control inputs based on robot.cpp's config.
     * Sends calculated output to motors.
     * @return N/A
     */
    void run() {

        pros::Controller master(pros::E_CONTROLLER_MASTER); // Imports Controller as "master"
        // bool held_R1 = false; // Held tracks the current E-CONTROLLER_DIGITAL_R1
        //  state; Halfcourt
        // bool held_R2 = false; // Held tracks the current E-CONTROLLER_DIGITAL_R2
        //  state; Point-Blank
        bool R1_State = false; // Tracker allowing for R1 toggle to function
        bool R2_State = false; // Tracker allowing for R2 toggle to function

        /* Tracks flywheel state 0: off 1: Halfcourt 2: Point-Blank
           Sets the motors to the values of the analog sticks. Calls the motorSpeed
           function from motors.cpp  */
        // int flywheelState = 0; /PART OF DEPRECATED CODE, pending
        // re-implimentation. See message below.

        // controls(); // Applies motor speeds following the preset control scheme for
        //  the drive

        /*if(Motors.Robot.training and master.get_digital(pros::E_CONTROLLER_DIGITAL_LEFT)) { // Calculates local limmiter
                                                                                            // from left stick's x value,
                                                                                            // uses the full stick range.
            limiter = (double)(master.get_analog(ANALOG_LEFT_X) + algo._RANGE) / 254;
        }*/

        // -- All listeners that are being used have been re-implimented --

        if(master.get_digital(DIGITAL_R1)) { // Toggles on button press, doesn't
                                             // hold up the control loop

            if(not(R1_State == (Motors.flywheelMotors.getSpeed() == algo._RANGE))) {
                R1_State = !R1_State;
            } // If motors are active and that's not the same as R1's state, it has
              // changed
            Motors.flywheelMotors.set(R1_State * algo._RANGE);
        }
        if(master.get_digital(DIGITAL_R2)) { // Toggles on button press, doesn't
                                             // hold up the control loop

            if(not(R2_State == (Motors.flywheelMotors.getSpeed() == algo._RANGE))) {
                R2_State = !R2_State;
            } // If motors are active and that's not the same as R1's state, it has
              // changed
            Motors.flywheelMotors.set(R2_State * algo._RANGE);
        }
        // REPLACE W/ Modular systems possibly in an event listener file, impliment in a future update

        // Toggle-able flywheel logic (Hold DIGITAL_A on the controller to
        // --DEPRECATED-- pending re-implimentation in a less complex way
        // activate/deactivate the flywheel)
        /*switch (master.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {
        case true: // When Controller Digital A is pushed
          // Uses held to track changes, compares it based off the
          // Controller_Digital_A value recorded
          if (!held_R1) {
            switch (flywheelState) {
            case 0:
              Motors.setSpeed(3, Flywheels.PID(3600));
              flywheelState = 1;
              break;
            case 1:
              Motors.setSpeed(3, 0);
              flywheelState = 0;
              break;
            case 2:
              Motors.setSpeed(3, Flywheels.PID(3600));
              flywheelState = 1;
              break;
            }
          }
          held_R1 = true;  // Sets comparison tracker "held" to true
        case false:        // When Controller Digital A is not pushed
          held_R1 = false; // Sets comparison tracker "held" to false
        default:
          return; // Returns if an erroneous values are detected. Should never
                  // happen, since digital outputs should be a 0 or 1.
        }
        switch (master.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {
        case true: // When Controller Digital A is pushed
          // Uses held to track changes, compares it based off the
          // Controller_Digital_A value recorded
          if (!held_R2) {
            // Toggles motor using motorCheck() tracking
            switch (flywheelState) {
            case 0:
              Motors.setSpeed(3, Flywheels.PID(2000));
              flywheelState = 2;
              break;
            case 1:
              Motors.setSpeed(3, Flywheels.PID(2000));
              flywheelState = 2;
              break;
            case 2:
              Motors.setSpeed(3, 0);
              flywheelState = 0;
              break;
            }
          }
          held_R2 = true;  // Sets comparison tracker "held" to true
        case false:        // When Controller Digital A is not pushed
          held_R2 = false; // Sets comparison tracker "held" to false
        default:
          return; // Returns if an erroneous values are detected. Should never
                  // happen, since digital outputs should be a 0 or 1.
        }*/
    }
};