#include "PID.cpp"
#include "pros/misc.h"

class cl {
private:
  double local_limiter = 100;
  double sc = 0;
  const int _RANGE = 127;
  const int _SPINNER_SPEED = 60; // Speed that spinner will spin at
  const int _SPINNER_DRIVE_SPEED = 10; // Speed for drive motors to push robot forward, keeping contact with spinner
  bool spinnerActive = false; // Allows for control while pushing robot forward for spinner (Quality of Life)
  Control Flywheels;
  public:
  Motor_Class Motors;
  void run() {

    pros::Controller master(pros::E_CONTROLLER_MASTER); // Imports Controller as "master"
    bool held_R1 = false; // Held tracks the current E-CONTROLLER_DIGITAL_R1
                          // state; Halfcourt
    bool held_R2 = false; // Held tracks the current E-CONTROLLER_DIGITAL_R2
                          // state; Point-Blank

    /* Tracks flywheel state 0: off 1: Halfcourt 2: Point-Blank
       Sets the motors to the values of the analog sticks. Calls the motorSpeed
       function from motors.cpp  */
       int flywheelState = 0; 
    

    if (master.get_digital(DIGITAL_L1)) {
      spinnerActive = true;
      Motors.setSpeed(4, _SPINNER_SPEED);}
    else if (master.get_digital(DIGITAL_L2)) {
      spinnerActive = true;
      Motors.setSpeed(4, -_SPINNER_SPEED);}
    else{
      spinnerActive = false;
      Motors.setSpeed(4, 0);
    }
    
    //master.get_digital(pros::E_CONTROLLER_DIGITAL_R2);
    if (Motors.Robot.training and master.get_digital(pros::E_CONTROLLER_DIGITAL_LEFT)) { // Calculates local limmiter from left stick's x value, uses the full stick range.
    local_limiter = (master.get_analog(ANALOG_LEFT_X) + _RANGE) / 2.54;
    }
    switch(Motors.Robot.controlScheme) {
      case 0: // Tank control
      if (-1 < (master.get_analog(ANALOG_LEFT_Y)) and (master.get_analog(ANALOG_LEFT_Y) < 1) and spinnerActive) {
        Motors.setSpeed(1, _SPINNER_DRIVE_SPEED);
        Motors.setSpeed(2, _SPINNER_DRIVE_SPEED);
      } else {
    Motors.setSpeed( 
        1, int(master.get_analog(ANALOG_LEFT_Y) * (local_limiter / 100)));
    Motors.setSpeed(
        2, int(master.get_analog(ANALOG_RIGHT_Y) * (local_limiter / 100)));}
      break;
      case 1: // Split Arcade
      if (-1 < (master.get_analog(ANALOG_LEFT_Y)) and (master.get_analog(ANALOG_LEFT_Y) < 1) and spinnerActive) {
        Motors.setSpeed(1, _SPINNER_DRIVE_SPEED);
        Motors.setSpeed(2, _SPINNER_DRIVE_SPEED);
      } else {
    // Designed to allow a mix of left/right forward/backwards inputs, so the scaling coefficient prevents overflow (values >170)
    sc = (abs(master.get_analog(ANALOG_LEFT_Y)) + abs(master.get_analog(ANALOG_RIGHT_X)));
    if (sc < _RANGE) {sc = _RANGE;} // If it isn't limiting the value (making the value larger instead), set it to do nothing (multiply by 1 (170/170))

    //Sets the motors to the values generated by the LEFT_Y and RIGHT_X stick ranges
    //Left_Y stick controls forward/backwards Right_X stick controls left/right and local limiter still works
    Motors.setSpeed(1, int((-(master.get_analog(ANALOG_LEFT_Y) / (sc / _RANGE) + master.get_analog(ANALOG_RIGHT_X) / (sc / _RANGE)) * (local_limiter / 100))));
    Motors.setSpeed(2, int(((master.get_analog(ANALOG_LEFT_Y) / (sc / _RANGE) - master.get_analog(ANALOG_RIGHT_X) / (sc / _RANGE)) * (local_limiter / 100))));}
      break;
      default:
      // SHOULD NEVER OCCUR, but if it does...
      // There is an error in variables.cpp in the Robot.controlScheme variable preset
      break;
    }
    

    // Toggle-able flywheel logic (Hold DIGITAL_A on the controller to
    // activate/deactivate the flywheel)
    switch (master.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {
    case true: // When Controller Digital A is pushed
      // Uses held to track changes, compares it based off the
      // Controller_Digital_A value recorded
      if (!held_R1) {
        switch (flywheelState) {
        case 0:
          Motors.setSpeed(3, Flywheels.PID(3600));
          flywheelState = 1;
          break;
        case 1:
          Motors.setSpeed(3, 0);
          flywheelState = 0;
          break;
        case 2:
          Motors.setSpeed(3, Flywheels.PID(3600));
          flywheelState = 1;
          break;
        }
      }
      held_R1 = true;  // Sets comparison tracker "held" to true
    case false:        // When Controller Digital A is not pushed
      held_R1 = false; // Sets comparison tracker "held" to false
    default:
      return; // Returns if an erroneous values are detected. Should never
              // happen, since digital outputs should be a 0 or 1.
    }
    switch (master.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {
    case true: // When Controller Digital A is pushed
      // Uses held to track changes, compares it based off the
      // Controller_Digital_A value recorded
      if (!held_R2) {
        // Toggles motor using motorCheck() tracking
        switch (flywheelState) {
        case 0:
          Motors.setSpeed(3, Flywheels.PID(2000));
          flywheelState = 2;
          break;
        case 1:
          Motors.setSpeed(3, Flywheels.PID(2000));
          flywheelState = 2;
          break;
        case 2:
          Motors.setSpeed(3, 0);
          flywheelState = 0;
          break;
        }
      }
      held_R2 = true;  // Sets comparison tracker "held" to true
    case false:        // When Controller Digital A is not pushed
      held_R2 = false; // Sets comparison tracker "held" to false
    default:
      return; // Returns if an erroneous values are detected. Should never
              // happen, since digital outputs should be a 0 or 1.
    }
  }};