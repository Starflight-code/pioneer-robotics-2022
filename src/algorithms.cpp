#include <array>
#include <math.h>
class algorithms {
private:
    const int _RANGE = 170;

public:
    int castToInt(double x) { return (int)x; }
    int castToInt(int x) { return x; }
    /// Applys a limiter by multiplying a given value by the limiter, then casting as an int
    int applyLimiter(int x, double limiter) {
        return (int)x * limiter;
    }
    int exponential_control(int controlInput, double exponent) {
        int negativeCarry = (controlInput < 0) * -1; // Carrys the negative, would otherwise be lost during exponent calcualtion
        return negativeCarry * round(_RANGE * pow((controlInput / _RANGE), exponent));
    }
    int tank_control(int control_input, double limiter) {
        return applyLimiter(control_input, limiter);
    }
    std::array<int, 2> arcade_control(int controlInput_y, int controlInput_x, double limiter) {
        std::array<int, 2> motorOutput;
        // Designed to allow a mix of left/right forward/backwards inputs, so
        // the scaling coefficient prevents overflow (values >170)
        double sc = (abs(controlInput_y) + abs(controlInput_x));
        sc = sc < _RANGE ? _RANGE : sc;
        double scalingConstant = sc / _RANGE;
        // If it isn't limiting the value (making the value larger instead),
        // set it to do nothing (multiply by 1 (127/127))

        // Sets the motors to the values generated by the LEFT_Y and RIGHT_X
        // stick ranges Left_Y stick controls forward/backwards Right_X stick
        // controls left/right and local limiter still works
        motorOutput[0] = castToInt(((-(controlInput_y / scalingConstant +
                                       controlInput_x / scalingConstant))));
        motorOutput[1] = castToInt(((controlInput_y / scalingConstant -
                                     controlInput_x / scalingConstant)));
        for(int i = 0; i < motorOutput.size(); i++) { // Applys limiter
            motorOutput[i] = applyLimiter(motorOutput[i], limiter);
        }
        return motorOutput;
    }
};